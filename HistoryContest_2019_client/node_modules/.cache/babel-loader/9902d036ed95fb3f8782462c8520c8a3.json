{"ast":null,"code":"\"use strict\";\n\nmodule.exports = GenericCollection;\n\nfunction GenericCollection() {\n  throw new Error(\"Can't construct. GenericCollection is a mixin.\");\n}\n\nGenericCollection.EmptyArray = Object.freeze([]);\n\nGenericCollection.prototype.addEach = function (values) {\n  if (values && Object(values) === values) {\n    if (typeof values.forEach === \"function\") {\n      values.forEach(this.add, this);\n    } else if (typeof values.length === \"number\") {\n      // Array-like objects that do not implement forEach, ergo,\n      // Arguments\n      for (var i = 0; i < values.length; i++) {\n        this.add(values[i], i);\n      }\n    } else {\n      Object.keys(values).forEach(function (key) {\n        this.add(values[key], key);\n      }, this);\n    }\n  } else if (values && typeof values.length === \"number\") {\n    // Strings\n    for (var i = 0; i < values.length; i++) {\n      this.add(values[i], i);\n    }\n  }\n\n  return this;\n}; // This is sufficiently generic for Map (since the value may be a key)\n// and ordered collections (since it forwards the equals argument)\n\n\nGenericCollection.prototype.deleteEach = function (values, equals) {\n  values.forEach(function (value) {\n    this[\"delete\"](value, equals);\n  }, this);\n  return this;\n}; // all of the following functions are implemented in terms of \"reduce\".\n// some need \"constructClone\".\n\n\nGenericCollection.prototype.forEach = function (callback\n/*, thisp*/\n) {\n  var thisp = arguments[1];\n  return this.reduce(function (undefined, value, key, object, depth) {\n    callback.call(thisp, value, key, object, depth);\n  }, undefined);\n};\n\nGenericCollection.prototype.map = function (callback\n/*, thisp*/\n) {\n  var thisp = arguments[1];\n  var result = [];\n  this.reduce(function (undefined, value, key, object, depth) {\n    result.push(callback.call(thisp, value, key, object, depth));\n  }, undefined);\n  return result;\n};\n\nGenericCollection.prototype.enumerate = function (start) {\n  if (start == null) {\n    start = 0;\n  }\n\n  var result = [];\n  this.reduce(function (undefined, value) {\n    result.push([start++, value]);\n  }, undefined);\n  return result;\n};\n\nGenericCollection.prototype.group = function (callback, thisp, equals) {\n  equals = equals || Object.equals;\n  var groups = [];\n  var keys = [];\n  this.forEach(function (value, key, object) {\n    var key = callback.call(thisp, value, key, object);\n    var index = keys.indexOf(key, equals);\n    var group;\n\n    if (index === -1) {\n      group = [];\n      groups.push([key, group]);\n      keys.push(key);\n    } else {\n      group = groups[index][1];\n    }\n\n    group.push(value);\n  });\n  return groups;\n};\n\nGenericCollection.prototype.toArray = function () {\n  return this.map(Function.identity);\n}; // this depends on stringable keys, which apply to Array and Iterator\n// because they have numeric keys and all Maps since they may use\n// strings as keys.  List, Set, and SortedSet have nodes for keys, so\n// toObject would not be meaningful.\n\n\nGenericCollection.prototype.toObject = function () {\n  var object = {};\n  this.reduce(function (undefined, value, key) {\n    object[key] = value;\n  }, undefined);\n  return object;\n};\n\nGenericCollection.prototype.filter = function (callback\n/*, thisp*/\n) {\n  var thisp = arguments[1];\n  var result = this.constructClone();\n  this.reduce(function (undefined, value, key, object, depth) {\n    if (callback.call(thisp, value, key, object, depth)) {\n      result.add(value, key);\n    }\n  }, undefined);\n  return result;\n};\n\nGenericCollection.prototype.every = function (callback\n/*, thisp*/\n) {\n  var thisp = arguments[1];\n  return this.reduce(function (result, value, key, object, depth) {\n    return result && callback.call(thisp, value, key, object, depth);\n  }, true);\n};\n\nGenericCollection.prototype.some = function (callback\n/*, thisp*/\n) {\n  var thisp = arguments[1];\n  return this.reduce(function (result, value, key, object, depth) {\n    return result || callback.call(thisp, value, key, object, depth);\n  }, false);\n};\n\nGenericCollection.prototype.all = function () {\n  return this.every(Boolean);\n};\n\nGenericCollection.prototype.any = function () {\n  return this.some(Boolean);\n};\n\nGenericCollection.prototype.min = function (compare) {\n  compare = compare || this.contentCompare || Object.compare;\n  var first = true;\n  return this.reduce(function (result, value) {\n    if (first) {\n      first = false;\n      return value;\n    } else {\n      return compare(value, result) < 0 ? value : result;\n    }\n  }, undefined);\n};\n\nGenericCollection.prototype.max = function (compare) {\n  compare = compare || this.contentCompare || Object.compare;\n  var first = true;\n  return this.reduce(function (result, value) {\n    if (first) {\n      first = false;\n      return value;\n    } else {\n      return compare(value, result) > 0 ? value : result;\n    }\n  }, undefined);\n};\n\nGenericCollection.prototype.sum = function (zero) {\n  zero = zero === undefined ? 0 : zero;\n  return this.reduce(function (a, b) {\n    return a + b;\n  }, zero);\n};\n\nGenericCollection.prototype.average = function (zero) {\n  var sum = zero === undefined ? 0 : zero;\n  var count = zero === undefined ? 0 : zero;\n  this.reduce(function (undefined, value) {\n    sum += value;\n    count += 1;\n  }, undefined);\n  return sum / count;\n};\n\nGenericCollection.prototype.concat = function () {\n  var result = this.constructClone(this);\n\n  for (var i = 0; i < arguments.length; i++) {\n    result.addEach(arguments[i]);\n  }\n\n  return result;\n};\n\nGenericCollection.prototype.flatten = function () {\n  var self = this;\n  return this.reduce(function (result, array) {\n    array.forEach(function (value) {\n      this.push(value);\n    }, result, self);\n    return result;\n  }, []);\n};\n\nGenericCollection.prototype.zip = function () {\n  var table = Array.prototype.slice.call(arguments);\n  table.unshift(this);\n  return Array.unzip(table);\n};\n\nGenericCollection.prototype.join = function (delimiter) {\n  return this.reduce(function (result, string) {\n    // work-around for reduce that does not support no-basis form\n    if (result === void 0) {\n      return string;\n    } else {\n      return result + delimiter + string;\n    }\n  }, void 0);\n};\n\nGenericCollection.prototype.sorted = function (compare, by, order) {\n  compare = compare || this.contentCompare || Object.compare; // account for comparators generated by Function.by\n\n  if (compare.by) {\n    by = compare.by;\n    compare = compare.compare || this.contentCompare || Object.compare;\n  } else {\n    by = by || Function.identity;\n  }\n\n  if (order === undefined) order = 1;\n  return this.map(function (item) {\n    return {\n      by: by(item),\n      value: item\n    };\n  }).sort(function (a, b) {\n    return compare(a.by, b.by) * order;\n  }).map(function (pair) {\n    return pair.value;\n  });\n};\n\nGenericCollection.prototype.reversed = function () {\n  return this.constructClone(this).reverse();\n};\n\nGenericCollection.prototype.clone = function (depth, memo) {\n  if (depth === undefined) {\n    depth = Infinity;\n  } else if (depth === 0) {\n    return this;\n  }\n\n  var clone = this.constructClone();\n  this.forEach(function (value, key) {\n    clone.add(Object.clone(value, depth - 1, memo), key);\n  }, this);\n  return clone;\n};\n\nGenericCollection.prototype.only = function () {\n  if (this.length === 1) {\n    return this.one();\n  }\n};\n\nGenericCollection.prototype.iterator = function () {\n  return this.iterate.apply(this, arguments);\n};\n\nGenericCollection._sizePropertyDescriptor = {\n  get: function () {\n    return this.length;\n  },\n  enumerable: false,\n  configurable: true\n};\nObject.defineProperty(GenericCollection.prototype, \"size\", GenericCollection._sizePropertyDescriptor);\n\nrequire(\"./shim-array\");","map":null,"metadata":{},"sourceType":"script"}