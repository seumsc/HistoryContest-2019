{"ast":null,"code":"\"use strict\";\n\nvar WeakMap = require(\"weak-map\");\n\nmodule.exports = Object;\n/*\n    Based in part on extras from Motorola Mobilityâ€™s Montage\n    Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.\n    3-Clause BSD License\n    https://github.com/motorola-mobility/montage/blob/master/LICENSE.md\n*/\n\n/**\n    Defines extensions to intrinsic <code>Object</code>.\n    @see [Object class]{@link external:Object}\n*/\n\n/**\n    A utility object to avoid unnecessary allocations of an empty object\n    <code>{}</code>.  This object is frozen so it is safe to share.\n\n    @object external:Object.empty\n*/\n\nObject.empty = Object.freeze(Object.create(null));\n/**\n    Returns whether the given value is an object, as opposed to a value.\n    Unboxed numbers, strings, true, false, undefined, and null are not\n    objects.  Arrays are objects.\n\n    @function external:Object.isObject\n    @param {Any} value\n    @returns {Boolean} whether the given value is an object\n*/\n\nObject.isObject = function (object) {\n  return Object(object) === object;\n};\n/**\n    Returns the value of an any value, particularly objects that\n    implement <code>valueOf</code>.\n\n    <p>Note that, unlike the precedent of methods like\n    <code>Object.equals</code> and <code>Object.compare</code> would suggest,\n    this method is named <code>Object.getValueOf</code> instead of\n    <code>valueOf</code>.  This is a delicate issue, but the basis of this\n    decision is that the JavaScript runtime would be far more likely to\n    accidentally call this method with no arguments, assuming that it would\n    return the value of <code>Object</code> itself in various situations,\n    whereas <code>Object.equals(Object, null)</code> protects against this case\n    by noting that <code>Object</code> owns the <code>equals</code> property\n    and therefore does not delegate to it.\n\n    @function external:Object.getValueOf\n    @param {Any} value a value or object wrapping a value\n    @returns {Any} the primitive value of that object, if one exists, or passes\n    the value through\n*/\n\n\nObject.getValueOf = function (value) {\n  if (value && typeof value.valueOf === \"function\") {\n    value = value.valueOf();\n  }\n\n  return value;\n};\n\nvar hashMap = new WeakMap();\n\nObject.hash = function (object) {\n  if (object && typeof object.hash === \"function\") {\n    return \"\" + object.hash();\n  } else if (Object(object) === object) {\n    if (!hashMap.has(object)) {\n      hashMap.set(object, Math.random().toString(36).slice(2));\n    }\n\n    return hashMap.get(object);\n  } else {\n    return \"\" + object;\n  }\n};\n/**\n    A shorthand for <code>Object.prototype.hasOwnProperty.call(object,\n    key)</code>.  Returns whether the object owns a property for the given key.\n    It does not consult the prototype chain and works for any string (including\n    \"hasOwnProperty\") except \"__proto__\".\n\n    @function external:Object.owns\n    @param {Object} object\n    @param {String} key\n    @returns {Boolean} whether the object owns a property wfor the given key.\n*/\n\n\nvar owns = Object.prototype.hasOwnProperty;\n\nObject.owns = function (object, key) {\n  return owns.call(object, key);\n};\n/**\n    A utility that is like Object.owns but is also useful for finding\n    properties on the prototype chain, provided that they do not refer to\n    methods on the Object prototype.  Works for all strings except \"__proto__\".\n\n    <p>Alternately, you could use the \"in\" operator as long as the object\n    descends from \"null\" instead of the Object.prototype, as with\n    <code>Object.create(null)</code>.  However,\n    <code>Object.create(null)</code> only works in fully compliant EcmaScript 5\n    JavaScript engines and cannot be faithfully shimmed.\n\n    <p>If the given object is an instance of a type that implements a method\n    named \"has\", this function defers to the collection, so this method can be\n    used to generically handle objects, arrays, or other collections.  In that\n    case, the domain of the key depends on the instance.\n\n    @param {Object} object\n    @param {String} key\n    @returns {Boolean} whether the object, or any of its prototypes except\n    <code>Object.prototype</code>\n    @function external:Object.has\n*/\n\n\nObject.has = function (object, key) {\n  if (typeof object !== \"object\") {\n    throw new Error(\"Object.has can't accept non-object: \" + typeof object);\n  } // forward to mapped collections that implement \"has\"\n\n\n  if (object && typeof object.has === \"function\") {\n    return object.has(key); // otherwise report whether the key is on the prototype chain,\n    // as long as it is not one of the methods on object.prototype\n  } else if (typeof key === \"string\") {\n    return key in object && object[key] !== Object.prototype[key];\n  } else {\n    throw new Error(\"Key must be a string for Object.has on plain objects\");\n  }\n};\n/**\n    Gets the value for a corresponding key from an object.\n\n    <p>Uses Object.has to determine whether there is a corresponding value for\n    the given key.  As such, <code>Object.get</code> is capable of retriving\n    values from the prototype chain as long as they are not from the\n    <code>Object.prototype</code>.\n\n    <p>If there is no corresponding value, returns the given default, which may\n    be <code>undefined</code>.\n\n    <p>If the given object is an instance of a type that implements a method\n    named \"get\", this function defers to the collection, so this method can be\n    used to generically handle objects, arrays, or other collections.  In that\n    case, the domain of the key depends on the implementation.  For a `Map`,\n    for example, the key might be any object.\n\n    @param {Object} object\n    @param {String} key\n    @param {Any} value a default to return, <code>undefined</code> if omitted\n    @returns {Any} value for key, or default value\n    @function external:Object.get\n*/\n\n\nObject.get = function (object, key, value) {\n  if (typeof object !== \"object\") {\n    throw new Error(\"Object.get can't accept non-object: \" + typeof object);\n  } // forward to mapped collections that implement \"get\"\n\n\n  if (object && typeof object.get === \"function\") {\n    return object.get(key, value);\n  } else if (Object.has(object, key)) {\n    return object[key];\n  } else {\n    return value;\n  }\n};\n/**\n    Sets the value for a given key on an object.\n\n    <p>If the given object is an instance of a type that implements a method\n    named \"set\", this function defers to the collection, so this method can be\n    used to generically handle objects, arrays, or other collections.  As such,\n    the key domain varies by the object type.\n\n    @param {Object} object\n    @param {String} key\n    @param {Any} value\n    @returns <code>undefined</code>\n    @function external:Object.set\n*/\n\n\nObject.set = function (object, key, value) {\n  if (object && typeof object.set === \"function\") {\n    object.set(key, value);\n  } else {\n    object[key] = value;\n  }\n};\n\nObject.addEach = function (target, source) {\n  if (!source) {} else if (typeof source.forEach === \"function\" && !source.hasOwnProperty(\"forEach\")) {\n    // copy map-alikes\n    if (source.isMap === true) {\n      source.forEach(function (value, key) {\n        target[key] = value;\n      }); // iterate key value pairs of other iterables\n    } else {\n      source.forEach(function (pair) {\n        target[pair[0]] = pair[1];\n      });\n    }\n  } else if (typeof source.length === \"number\") {\n    // arguments, strings\n    for (var index = 0; index < source.length; index++) {\n      target[index] = source[index];\n    }\n  } else {\n    // copy other objects as map-alikes\n    Object.keys(source).forEach(function (key) {\n      target[key] = source[key];\n    });\n  }\n\n  return target;\n};\n/**\n    Iterates over the owned properties of an object.\n\n    @function external:Object.forEach\n    @param {Object} object an object to iterate.\n    @param {Function} callback a function to call for every key and value\n    pair in the object.  Receives <code>value</code>, <code>key</code>,\n    and <code>object</code> as arguments.\n    @param {Object} thisp the <code>this</code> to pass through to the\n    callback\n*/\n\n\nObject.forEach = function (object, callback, thisp) {\n  var keys = Object.keys(object),\n      i = 0,\n      iKey;\n\n  for (; iKey = keys[i]; i++) {\n    callback.call(thisp, object[iKey], iKey, object);\n  }\n};\n/**\n    Iterates over the owned properties of a map, constructing a new array of\n    mapped values.\n\n    @function external:Object.map\n    @param {Object} object an object to iterate.\n    @param {Function} callback a function to call for every key and value\n    pair in the object.  Receives <code>value</code>, <code>key</code>,\n    and <code>object</code> as arguments.\n    @param {Object} thisp the <code>this</code> to pass through to the\n    callback\n    @returns {Array} the respective values returned by the callback for each\n    item in the object.\n*/\n\n\nObject.map = function (object, callback, thisp) {\n  var keys = Object.keys(object),\n      i = 0,\n      result = [],\n      iKey;\n\n  for (; iKey = keys[i]; i++) {\n    result.push(callback.call(thisp, object[iKey], iKey, object));\n  }\n\n  return result;\n};\n/**\n    Returns the values for owned properties of an object.\n\n    @function external:Object.map\n    @param {Object} object\n    @returns {Array} the respective value for each owned property of the\n    object.\n*/\n\n\nObject.values = function (object) {\n  return Object.map(object, Function.identity);\n}; // TODO inline document concat\n\n\nObject.concat = function () {\n  var object = {};\n\n  for (var i = 0; i < arguments.length; i++) {\n    Object.addEach(object, arguments[i]);\n  }\n\n  return object;\n};\n\nObject.from = Object.concat;\n/**\n    Returns whether two values are identical.  Any value is identical to itself\n    and only itself.  This is much more restictive than equivalence and subtly\n    different than strict equality, <code>===</code> because of edge cases\n    including negative zero and <code>NaN</code>.  Identity is useful for\n    resolving collisions among keys in a mapping where the domain is any value.\n    This method does not delgate to any method on an object and cannot be\n    overridden.\n    @see http://wiki.ecmascript.org/doku.php?id=harmony:egal\n    @param {Any} this\n    @param {Any} that\n    @returns {Boolean} whether this and that are identical\n    @function external:Object.is\n*/\n\nObject.is = function (x, y) {\n  if (x === y) {\n    // 0 === -0, but they are not identical\n    return x !== 0 || 1 / x === 1 / y;\n  } // NaN !== NaN, but they are identical.\n  // NaNs are the only non-reflexive value, i.e., if x !== x,\n  // then x is a NaN.\n  // isNaN is broken: it converts its argument to number, so\n  // isNaN(\"foo\") => true\n\n\n  return x !== x && y !== y;\n};\n/**\n    Performs a polymorphic, type-sensitive deep equivalence comparison of any\n    two values.\n\n    <p>As a basic principle, any value is equivalent to itself (as in\n    identity), any boxed version of itself (as a <code>new Number(10)</code> is\n    to 10), and any deep clone of itself.\n\n    <p>Equivalence has the following properties:\n\n    <ul>\n        <li><strong>polymorphic:</strong>\n            If the given object is an instance of a type that implements a\n            methods named \"equals\", this function defers to the method.  So,\n            this function can safely compare any values regardless of type,\n            including undefined, null, numbers, strings, any pair of objects\n            where either implements \"equals\", or object literals that may even\n            contain an \"equals\" key.\n        <li><strong>type-sensitive:</strong>\n            Incomparable types are not equal.  No object is equivalent to any\n            array.  No string is equal to any other number.\n        <li><strong>deep:</strong>\n            Collections with equivalent content are equivalent, recursively.\n        <li><strong>equivalence:</strong>\n            Identical values and objects are equivalent, but so are collections\n            that contain equivalent content.  Whether order is important varies\n            by type.  For Arrays and lists, order is important.  For Objects,\n            maps, and sets, order is not important.  Boxed objects are mutally\n            equivalent with their unboxed values, by virtue of the standard\n            <code>valueOf</code> method.\n    </ul>\n    @param this\n    @param that\n    @returns {Boolean} whether the values are deeply equivalent\n    @function external:Object.equals\n*/\n\n\nObject.equals = function (a, b, equals, memo) {\n  equals = equals || Object.equals; // unbox objects, but do not confuse object literals\n\n  a = Object.getValueOf(a);\n  b = Object.getValueOf(b);\n  if (a === b) return true;\n\n  if (Object.isObject(a)) {\n    memo = memo || new WeakMap();\n\n    if (memo.has(a)) {\n      return true;\n    }\n\n    memo.set(a, true);\n  }\n\n  if (Object.isObject(a) && typeof a.equals === \"function\") {\n    return a.equals(b, equals, memo);\n  } // commutative\n\n\n  if (Object.isObject(b) && typeof b.equals === \"function\") {\n    return b.equals(a, equals, memo);\n  }\n\n  if (Object.isObject(a) && Object.isObject(b)) {\n    if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n      for (var name in a) {\n        if (!equals(a[name], b[name], equals, memo)) {\n          return false;\n        }\n      }\n\n      for (var name in b) {\n        if (!(name in a) || !equals(b[name], a[name], equals, memo)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  } // NaN !== NaN, but they are equal.\n  // NaNs are the only non-reflexive value, i.e., if x !== x,\n  // then x is a NaN.\n  // isNaN is broken: it converts its argument to number, so\n  // isNaN(\"foo\") => true\n  // We have established that a !== b, but if a !== a && b !== b, they are\n  // both NaN.\n\n\n  if (a !== a && b !== b) return true;\n  if (!a || !b) return a === b;\n  return false;\n}; // Because a return value of 0 from a `compare` function  may mean either\n// \"equals\" or \"is incomparable\", `equals` cannot be defined in terms of\n// `compare`.  However, `compare` *can* be defined in terms of `equals` and\n// `lessThan`.  Again however, more often it would be desirable to implement\n// all of the comparison functions in terms of compare rather than the other\n// way around.\n\n/**\n    Determines the order in which any two objects should be sorted by returning\n    a number that has an analogous relationship to zero as the left value to\n    the right.  That is, if the left is \"less than\" the right, the returned\n    value will be \"less than\" zero, where \"less than\" may be any other\n    transitive relationship.\n\n    <p>Arrays are compared by the first diverging values, or by length.\n\n    <p>Any two values that are incomparable return zero.  As such,\n    <code>equals</code> should not be implemented with <code>compare</code>\n    since incomparability is indistinguishable from equality.\n\n    <p>Sorts strings lexicographically.  This is not suitable for any\n    particular international setting.  Different locales sort their phone books\n    in very different ways, particularly regarding diacritics and ligatures.\n\n    <p>If the given object is an instance of a type that implements a method\n    named \"compare\", this function defers to the instance.  The method does not\n    need to be an owned property to distinguish it from an object literal since\n    object literals are incomparable.  Unlike <code>Object</code> however,\n    <code>Array</code> implements <code>compare</code>.\n\n    @param {Any} left\n    @param {Any} right\n    @returns {Number} a value having the same transitive relationship to zero\n    as the left and right values.\n    @function external:Object.compare\n*/\n\n\nObject.compare = function (a, b) {\n  // unbox objects, but do not confuse object literals\n  // mercifully handles the Date case\n  a = Object.getValueOf(a);\n  b = Object.getValueOf(b);\n  if (a === b) return 0;\n  var aType = typeof a;\n  var bType = typeof b;\n  if (aType === \"number\" && bType === \"number\") return a - b;\n  if (aType === \"string\" && bType === \"string\") return a < b ? -Infinity : Infinity; // the possibility of equality elimiated above\n\n  if (a && typeof a.compare === \"function\") return a.compare(b); // not commutative, the relationship is reversed\n\n  if (b && typeof b.compare === \"function\") return -b.compare(a);\n  return 0;\n};\n/**\n    Creates a deep copy of any value.  Values, being immutable, are\n    returned without alternation.  Forwards to <code>clone</code> on\n    objects and arrays.\n\n    @function external:Object.clone\n    @param {Any} value a value to clone\n    @param {Number} depth an optional traversal depth, defaults to infinity.\n    A value of <code>0</code> means to make no clone and return the value\n    directly.\n    @param {Map} memo an optional memo of already visited objects to preserve\n    reference cycles.  The cloned object will have the exact same shape as the\n    original, but no identical objects.  Te map may be later used to associate\n    all objects in the original object graph with their corresponding member of\n    the cloned graph.\n    @returns a copy of the value\n*/\n\n\nObject.clone = function (value, depth, memo) {\n  value = Object.getValueOf(value);\n  memo = memo || new WeakMap();\n\n  if (depth === undefined) {\n    depth = Infinity;\n  } else if (depth === 0) {\n    return value;\n  }\n\n  if (Object.isObject(value)) {\n    if (!memo.has(value)) {\n      if (value && typeof value.clone === \"function\") {\n        memo.set(value, value.clone(depth, memo));\n      } else {\n        var prototype = Object.getPrototypeOf(value);\n\n        if (prototype === null || prototype === Object.prototype) {\n          var clone = Object.create(prototype);\n          memo.set(value, clone);\n\n          for (var key in value) {\n            clone[key] = Object.clone(value[key], depth - 1, memo);\n          }\n        } else {\n          throw new Error(\"Can't clone \" + value);\n        }\n      }\n    }\n\n    return memo.get(value);\n  }\n\n  return value;\n};\n/**\n    Removes all properties owned by this object making the object suitable for\n    reuse.\n\n    @function external:Object.clear\n    @returns this\n*/\n\n\nObject.clear = function (object) {\n  if (object && typeof object.clear === \"function\") {\n    object.clear();\n  } else {\n    var keys = Object.keys(object),\n        i = keys.length;\n\n    while (i) {\n      i--;\n      delete object[keys[i]];\n    }\n  }\n\n  return object;\n};","map":null,"metadata":{},"sourceType":"script"}