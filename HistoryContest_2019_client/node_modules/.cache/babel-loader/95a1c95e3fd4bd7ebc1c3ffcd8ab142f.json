{"ast":null,"code":"\"use strict\";\n\nmodule.exports = List;\n\nvar Shim = require(\"./shim\");\n\nvar GenericCollection = require(\"./generic-collection\");\n\nvar GenericOrder = require(\"./generic-order\");\n\nvar PropertyChanges = require(\"./listen/property-changes\");\n\nvar RangeChanges = require(\"./listen/range-changes\");\n\nfunction List(values, equals, getDefault) {\n  if (!(this instanceof List)) {\n    return new List(values, equals, getDefault);\n  }\n\n  var head = this.head = new this.Node();\n  head.next = head;\n  head.prev = head;\n  this.contentEquals = equals || Object.equals;\n  this.getDefault = getDefault || Function.noop;\n  this.length = 0;\n  this.addEach(values);\n}\n\nList.List = List; // hack so require(\"list\").List will work in MontageJS\n\nObject.addEach(List.prototype, GenericCollection.prototype);\nObject.addEach(List.prototype, GenericOrder.prototype);\nObject.addEach(List.prototype, PropertyChanges.prototype);\nObject.addEach(List.prototype, RangeChanges.prototype);\n\nList.prototype.constructClone = function (values) {\n  return new this.constructor(values, this.contentEquals, this.getDefault);\n};\n\nList.prototype.find = function (value, equals, index) {\n  equals = equals || this.contentEquals;\n  var head = this.head;\n  var at = this.scan(index, head.next);\n\n  while (at !== head) {\n    if (equals(at.value, value)) {\n      return at;\n    }\n\n    at = at.next;\n  }\n};\n\nList.prototype.findLast = function (value, equals, index) {\n  equals = equals || this.contentEquals;\n  var head = this.head;\n  var at = this.scan(index, head.prev);\n\n  while (at !== head) {\n    if (equals(at.value, value)) {\n      return at;\n    }\n\n    at = at.prev;\n  }\n};\n\nList.prototype.has = function (value, equals) {\n  return !!this.find(value, equals);\n};\n\nList.prototype.get = function (value, equals) {\n  var found = this.find(value, equals);\n\n  if (found) {\n    return found.value;\n  }\n\n  return this.getDefault(value);\n}; // LIFO (delete removes the most recently added equivalent value)\n\n\nList.prototype[\"delete\"] = function (value, equals) {\n  var found = this.findLast(value, equals);\n\n  if (found) {\n    if (this.dispatchesRangeChanges) {\n      var plus = [];\n      var minus = [value];\n      this.dispatchBeforeRangeChange(plus, minus, found.index);\n    }\n\n    found[\"delete\"]();\n    this.length--;\n\n    if (this.dispatchesRangeChanges) {\n      this.updateIndexes(found.next, found.index);\n      this.dispatchRangeChange(plus, minus, found.index);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nList.prototype.deleteAll = function (value, equals) {\n  equals = equals || this.contentEquals;\n  var head = this.head;\n  var at = head.next;\n  var count = 0;\n\n  while (at !== head) {\n    if (equals(value, at.value)) {\n      at[\"delete\"]();\n      count++;\n    }\n\n    at = at.next;\n  }\n\n  this.length -= count;\n  return count;\n};\n\nList.prototype.clear = function () {\n  var plus, minus;\n\n  if (this.dispatchesRangeChanges) {\n    minus = this.toArray();\n    plus = [];\n    this.dispatchBeforeRangeChange(plus, minus, 0);\n  }\n\n  this.head.next = this.head.prev = this.head;\n  this.length = 0;\n\n  if (this.dispatchesRangeChanges) {\n    this.dispatchRangeChange(plus, minus, 0);\n  }\n};\n\nList.prototype.add = function (value) {\n  var node = new this.Node(value);\n\n  if (this.dispatchesRangeChanges) {\n    node.index = this.length;\n    this.dispatchBeforeRangeChange([value], [], node.index);\n  }\n\n  this.head.addBefore(node);\n  this.length++;\n\n  if (this.dispatchesRangeChanges) {\n    this.dispatchRangeChange([value], [], node.index);\n  }\n\n  return true;\n};\n\nList.prototype.push = function () {\n  var head = this.head;\n\n  if (this.dispatchesRangeChanges) {\n    var plus = Array.prototype.slice.call(arguments);\n    var minus = [];\n    var index = this.length;\n    this.dispatchBeforeRangeChange(plus, minus, index);\n    var start = this.head.prev;\n  }\n\n  for (var i = 0; i < arguments.length; i++) {\n    var value = arguments[i];\n    var node = new this.Node(value);\n    head.addBefore(node);\n  }\n\n  this.length += arguments.length;\n\n  if (this.dispatchesRangeChanges) {\n    this.updateIndexes(start.next, start.index === undefined ? 0 : start.index + 1);\n    this.dispatchRangeChange(plus, minus, index);\n  }\n};\n\nList.prototype.unshift = function () {\n  if (this.dispatchesRangeChanges) {\n    var plus = Array.prototype.slice.call(arguments);\n    var minus = [];\n    this.dispatchBeforeRangeChange(plus, minus, 0);\n  }\n\n  var at = this.head;\n\n  for (var i = 0; i < arguments.length; i++) {\n    var value = arguments[i];\n    var node = new this.Node(value);\n    at.addAfter(node);\n    at = node;\n  }\n\n  this.length += arguments.length;\n\n  if (this.dispatchesRangeChanges) {\n    this.updateIndexes(this.head.next, 0);\n    this.dispatchRangeChange(plus, minus, 0);\n  }\n};\n\nList.prototype.pop = function () {\n  var value;\n  var head = this.head;\n\n  if (head.prev !== head) {\n    value = head.prev.value;\n\n    if (this.dispatchesRangeChanges) {\n      var plus = [];\n      var minus = [value];\n      var index = this.length - 1;\n      this.dispatchBeforeRangeChange(plus, minus, index);\n    }\n\n    head.prev['delete']();\n    this.length--;\n\n    if (this.dispatchesRangeChanges) {\n      this.dispatchRangeChange(plus, minus, index);\n    }\n  }\n\n  return value;\n};\n\nList.prototype.shift = function () {\n  var value;\n  var head = this.head;\n\n  if (head.prev !== head) {\n    value = head.next.value;\n\n    if (this.dispatchesRangeChanges) {\n      var plus = [];\n      var minus = [value];\n      this.dispatchBeforeRangeChange(plus, minus, 0);\n    }\n\n    head.next['delete']();\n    this.length--;\n\n    if (this.dispatchesRangeChanges) {\n      this.updateIndexes(this.head.next, 0);\n      this.dispatchRangeChange(plus, minus, 0);\n    }\n  }\n\n  return value;\n};\n\nList.prototype.peek = function () {\n  if (this.head !== this.head.next) {\n    return this.head.next.value;\n  }\n};\n\nList.prototype.poke = function (value) {\n  if (this.head !== this.head.next) {\n    this.head.next.value = value;\n  } else {\n    this.push(value);\n  }\n};\n\nList.prototype.one = function () {\n  return this.peek();\n}; // TODO\n// List.prototype.indexOf = function (value) {\n// };\n// TODO\n// List.prototype.lastIndexOf = function (value) {\n// };\n// an internal utility for coercing index offsets to nodes\n\n\nList.prototype.scan = function (at, fallback) {\n  var head = this.head;\n\n  if (typeof at === \"number\") {\n    var count = at;\n\n    if (count >= 0) {\n      at = head.next;\n\n      while (count) {\n        count--;\n        at = at.next;\n\n        if (at == head) {\n          break;\n        }\n      }\n    } else {\n      at = head;\n\n      while (count < 0) {\n        count++;\n        at = at.prev;\n\n        if (at == head) {\n          break;\n        }\n      }\n    }\n\n    return at;\n  } else {\n    return at || fallback;\n  }\n}; // at and end may both be positive or negative numbers (in which cases they\n// correspond to numeric indicies, or nodes)\n\n\nList.prototype.slice = function (at, end) {\n  var sliced = [];\n  var head = this.head;\n  at = this.scan(at, head.next);\n  end = this.scan(end, head);\n\n  while (at !== end && at !== head) {\n    sliced.push(at.value);\n    at = at.next;\n  }\n\n  return sliced;\n};\n\nList.prototype.splice = function (at, length\n/*...plus*/\n) {\n  return this.swap(at, length, Array.prototype.slice.call(arguments, 2));\n};\n\nList.prototype.swap = function (start, length, plus) {\n  var initial = start; // start will be head if start is null or -1 (meaning from the end), but\n  // will be head.next if start is 0 (meaning from the beginning)\n\n  start = this.scan(start, this.head);\n\n  if (length == null) {\n    length = Infinity;\n  }\n\n  plus = Array.from(plus); // collect the minus array\n\n  var minus = [];\n  var at = start;\n\n  while (length-- && length >= 0 && at !== this.head) {\n    minus.push(at.value);\n    at = at.next;\n  } // before range change\n\n\n  var index, startNode;\n\n  if (this.dispatchesRangeChanges) {\n    if (start === this.head) {\n      index = this.length;\n    } else if (start.prev === this.head) {\n      index = 0;\n    } else {\n      index = start.index;\n    }\n\n    startNode = start.prev;\n    this.dispatchBeforeRangeChange(plus, minus, index);\n  } // delete minus\n\n\n  var at = start;\n\n  for (var i = 0, at = start; i < minus.length; i++, at = at.next) {\n    at[\"delete\"]();\n  } // add plus\n\n\n  if (initial == null && at === this.head) {\n    at = this.head.next;\n  }\n\n  for (var i = 0; i < plus.length; i++) {\n    var node = new this.Node(plus[i]);\n    at.addBefore(node);\n  } // adjust length\n\n\n  this.length += plus.length - minus.length; // after range change\n\n  if (this.dispatchesRangeChanges) {\n    if (start === this.head) {\n      this.updateIndexes(this.head.next, 0);\n    } else {\n      this.updateIndexes(startNode.next, startNode.index + 1);\n    }\n\n    this.dispatchRangeChange(plus, minus, index);\n  }\n\n  return minus;\n};\n\nList.prototype.reverse = function () {\n  if (this.dispatchesRangeChanges) {\n    var minus = this.toArray();\n    var plus = minus.reversed();\n    this.dispatchBeforeRangeChange(plus, minus, 0);\n  }\n\n  var at = this.head;\n\n  do {\n    var temp = at.next;\n    at.next = at.prev;\n    at.prev = temp;\n    at = at.next;\n  } while (at !== this.head);\n\n  if (this.dispatchesRangeChanges) {\n    this.dispatchRangeChange(plus, minus, 0);\n  }\n\n  return this;\n};\n\nList.prototype.sort = function () {\n  this.swap(0, this.length, this.sorted());\n}; // TODO account for missing basis argument\n\n\nList.prototype.reduce = function (callback, basis\n/*, thisp*/\n) {\n  var thisp = arguments[2];\n  var head = this.head;\n  var at = head.next;\n\n  while (at !== head) {\n    basis = callback.call(thisp, basis, at.value, at, this);\n    at = at.next;\n  }\n\n  return basis;\n};\n\nList.prototype.reduceRight = function (callback, basis\n/*, thisp*/\n) {\n  var thisp = arguments[2];\n  var head = this.head;\n  var at = head.prev;\n\n  while (at !== head) {\n    basis = callback.call(thisp, basis, at.value, at, this);\n    at = at.prev;\n  }\n\n  return basis;\n};\n\nList.prototype.updateIndexes = function (node, index) {\n  while (node !== this.head) {\n    node.index = index++;\n    node = node.next;\n  }\n};\n\nList.prototype.makeObservable = function () {\n  this.head.index = -1;\n  this.updateIndexes(this.head.next, 0);\n  this.dispatchesRangeChanges = true;\n};\n\nList.prototype.iterate = function () {\n  return new ListIterator(this.head);\n};\n\nfunction ListIterator(head) {\n  this.head = head;\n  this.at = head.next;\n}\n\n;\nListIterator.prototype.__iterationObject = null;\nObject.defineProperty(ListIterator.prototype, \"_iterationObject\", {\n  get: function () {\n    return this.__iterationObject || (this.__iterationObject = {\n      done: false,\n      value: null\n    });\n  }\n});\n\nListIterator.prototype.next = function () {\n  if (this.at === this.head) {\n    this._iterationObject.done = true;\n    this._iterationObject.value = void 0;\n  } else {\n    var value = this.at.value;\n    this.at = this.at.next;\n    this._iterationObject.value = value;\n  }\n\n  return this._iterationObject;\n};\n\nList.prototype.Node = Node;\n\nfunction Node(value) {\n  this.value = value;\n  this.prev = null;\n  this.next = null;\n}\n\n;\n\nNode.prototype[\"delete\"] = function () {\n  this.prev.next = this.next;\n  this.next.prev = this.prev;\n};\n\nNode.prototype.addBefore = function (node) {\n  var prev = this.prev;\n  this.prev = node;\n  node.prev = prev;\n  prev.next = node;\n  node.next = this;\n};\n\nNode.prototype.addAfter = function (node) {\n  var next = this.next;\n  this.next = node;\n  node.next = next;\n  next.prev = node;\n  node.prev = this;\n};","map":null,"metadata":{},"sourceType":"script"}