import _extends from 'babel-runtime/helpers/extends';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { createElement } from 'react';
import PropTypes from 'prop-types';
import TweenOne, { ticker } from 'rc-tween-one';
import { toArrayChildren, findChildInChildrenByKey, mergeChildren, transformArguments, getChildrenFromProps } from './utils';
import AnimTypes from './animTypes';

var noop = function noop() {};

var typeDefault = ['displayName', 'propTypes', 'getDefaultProps', 'defaultProps', 'childContextTypes', 'contextTypes'];

var QueueAnim = function (_React$Component) {
  _inherits(QueueAnim, _React$Component);

  function QueueAnim(props) {
    _classCallCheck(this, QueueAnim);

    /**
     * @param tweenToEnter;
     * 记录强制切换时是否需要添加 animation;
     * 如 enter 后, leave -> enter，样式是没有发生变化，就不需要添加 animation 属性。
     */
    var _this = _possibleConstructorReturn(this, (QueueAnim.__proto__ || Object.getPrototypeOf(QueueAnim)).call(this, props));

    _initialiseProps.call(_this);

    _this.tweenToEnter = {};
    /**
     * @param leaveUnfinishedChild;
     * 记录多次切换，出场没完成动画的 key。
     */
    _this.leaveUnfinishedChild = [];
    /**
     * @param saveTweenOneTag;
     * 记录 TweenOne 标签，在 leaveUnfinishedChild 里使用，残留的元素不需要考虑 props 的变更。
     */
    _this.saveTweenOneTag = {};
    /**
     * @param enterAnimation;
     * 记录进场的动画, 在没进场完成, 将进场的动画保存，免得重新生成。
     */
    _this.enterAnimation = {};
    /**
     * @param childrenShow;
     * 记录 animation 里是否需要 startAnim;
     * 当前元素是否处在显示状态
     * enterBegin 到 leaveComplete 之前都处于显示状态
     */
    _this.childrenShow = {};
    /**
     * @param keysToEnter;
     * 记录进场的 key;
     */
    _this.keysToEnter = [];
    /**
     * @param keysToLeave;
     * 记录出场的 key;
     */
    _this.keysToLeave = [];
    /**
     * @param keysToEnterPaused;
     * 记录在进入时是否处理暂停状态
     */
    _this.keysToEnterPaused = {};
    /**
     * @param placeholderTimeoutIds;
     * 进场时 deley 的 timeout 记录;
     */
    _this.placeholderTimeoutIds = {};
    // 第一次进入，默认进场
    var children = toArrayChildren(getChildrenFromProps(props));
    var childrenShow = {};
    children.forEach(function (child) {
      if (!child || !child.key) {
        return;
      }
      if (_this.props.appear) {
        _this.keysToEnter.push(child.key);
      } else {
        childrenShow[child.key] = true;
        _this.tweenToEnter[child.key] = true;
      }
    });
    _this.keysToEnterToCallback = [].concat(_toConsumableArray(_this.keysToEnter));
    _this.originalChildren = toArrayChildren(getChildrenFromProps(props));
    _this.state = {
      children: children,
      childrenShow: childrenShow
    };
    return _this;
  }

  _createClass(QueueAnim, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.props.appear) {
        this.componentDidUpdate();
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      var nextChildren = toArrayChildren(nextProps.children).filter(function (item) {
        return item;
      });
      var currentChildren = this.originalChildren.filter(function (item) {
        return item;
      });
      if (this.state.children.length) {
        /**
         * 多次刷新处理
         * 如果 state.children 里还有元素，元素还在动画，当前子级加回在出场的子级;
         */
        var leaveChild = this.state.children.filter(function (item) {
          return item && _this2.keysToLeave.indexOf(item.key) >= 0;
        });
        this.leaveUnfinishedChild = leaveChild.map(function (item) {
          return item.key;
        });
        /**
         * 获取 leaveChild 在 state.children 里的序列，再将 leaveChild 和 currentChildren 的重新排序。
         * 避逸 state.children 在 leaveComplete 里没全部完成不触发，
         * leaveComplete 里如果动画完成了是会删除 keyToLeave，但 state.children 是在全部出场后才触发清除，
         * 所以这里需要处理出场完成的元素做清除。
         */
        var stateChildrens = mergeChildren(currentChildren, this.state.children);
        var currentChild = [];
        var childReOrder = function childReOrder(child) {
          child.forEach(function (item) {
            var order = stateChildrens.indexOf(item);
            // -1 不应该出现的情况，直接插入数组后面.
            if (order === -1) {
              currentChild.push(item);
            } else {
              currentChild.splice(order, 0, item);
            }
          });
        };
        childReOrder(leaveChild);
        childReOrder(currentChildren);
        currentChildren = currentChild.filter(function (c) {
          return c;
        });
      }
      var newChildren = mergeChildren(currentChildren, nextChildren);

      var childrenShow = !newChildren.length ? {} : this.state.childrenShow;
      this.keysToEnterPaused = {};
      var emptyBool = !nextChildren.length && !currentChildren.length && this.state.children.length;
      /**
       * 在出场没结束时，childrenShow 里的值将不会清除。
       * 再触发进场时， childrenShow 里的值是保留着的, 设置了 forcedReplay 将重新播放进场。
       */
      if (!emptyBool) {
        // 空子级状态下刷新不做处理
        var nextKeys = nextChildren.map(function (c) {
          return c.key;
        });
        this.keysToLeave.forEach(function (key) {
          // 将所有在出场里的停止掉。避免间隔性出现
          if (nextKeys.indexOf(key) >= 0) {
            _this2.keysToEnterPaused[key] = true;
            currentChildren = currentChildren.filter(function (item) {
              return item.key !== key;
            });
            if (nextProps.forcedReplay) {
              // 清掉所有出场的。
              delete childrenShow[key];
            }
          }
        });
      }

      this.keysToEnter = [];
      this.keysToLeave = [];

      // need render to avoid update
      this.setState({
        childrenShow: childrenShow,
        children: newChildren
      });

      nextChildren.forEach(function (c) {
        if (!c) {
          return;
        }
        var key = c.key;
        var hasPrev = findChildInChildrenByKey(currentChildren, key);
        if (!hasPrev && key) {
          _this2.keysToEnter.push(key);
        }
      });

      currentChildren.forEach(function (c) {
        if (!c) {
          return;
        }
        var key = c.key;
        var hasNext = findChildInChildrenByKey(nextChildren, key);
        if (!hasNext && key) {
          _this2.keysToLeave.push(key);
          ticker.clear(_this2.placeholderTimeoutIds[key]);
          delete _this2.placeholderTimeoutIds[key];
        }
      });
      this.keysToEnterToCallback = [].concat(_toConsumableArray(this.keysToEnter));
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.originalChildren = toArrayChildren(getChildrenFromProps(this.props));
      var keysToEnter = [].concat(_toConsumableArray(this.keysToEnter));
      var keysToLeave = [].concat(_toConsumableArray(this.keysToLeave));
      keysToEnter.forEach(this.performEnter);
      keysToLeave.forEach(this.performLeave);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var _this3 = this;

      Object.keys(this.placeholderTimeoutIds).forEach(function (key) {
        ticker.clear(_this3.placeholderTimeoutIds[key]);
      });
      this.keysToEnter = [];
      this.keysToLeave = [];
      this.childrenShow = {};
    }
  }, {
    key: 'getTweenType',
    value: function getTweenType(type, num) {
      var data = AnimTypes[type];
      return this.getTweenAnimConfig(data, num);
    }
  }, {
    key: 'getTweenAnimConfig',
    value: function getTweenAnimConfig(data, num, enterOrLeave) {
      var _this4 = this;

      if (Array.isArray(data)) {
        return data.map(function (item) {
          return _this4.getTweenSingleConfig(item, num, enterOrLeave);
        });
      }
      return this.getTweenSingleConfig(data, num, enterOrLeave);
    }
  }, {
    key: 'render',
    value: function render() {
      var tagProps = _objectWithoutProperties(this.props, []);

      ['component', 'componentProps', 'interval', 'duration', 'delay', 'type', 'animConfig', 'ease', 'leaveReverse', 'animatingClassName', 'forcedReplay', 'onEnd', 'appear'].forEach(function (key) {
        return delete tagProps[key];
      });
      var childrenToRender = toArrayChildren(this.state.children).map(this.getChildrenToRender);
      var props = _extends({}, tagProps, this.props.componentProps);
      return createElement(this.props.component, props, childrenToRender);
    }
  }]);

  return QueueAnim;
}(React.Component);

QueueAnim.propTypes = {
  children: PropTypes.any,
  component: PropTypes.any,
  componentProps: PropTypes.object,
  interval: PropTypes.any,
  duration: PropTypes.any,
  delay: PropTypes.any,
  type: PropTypes.any,
  animConfig: PropTypes.any,
  ease: PropTypes.any,
  leaveReverse: PropTypes.bool,
  forcedReplay: PropTypes.bool,
  animatingClassName: PropTypes.array,
  onEnd: PropTypes.func,
  appear: PropTypes.bool
};
QueueAnim.defaultProps = {
  component: 'div',
  componentProps: {},
  interval: 100,
  duration: 450,
  delay: 0,
  type: 'right',
  animConfig: null,
  ease: 'easeOutQuart',
  leaveReverse: false,
  forcedReplay: false,
  animatingClassName: ['queue-anim-entering', 'queue-anim-leaving'],
  onEnd: noop,
  appear: true
};

var _initialiseProps = function _initialiseProps() {
  var _this5 = this;

  this.getTweenSingleConfig = function (data, num, enterOrLeave) {
    var obj = {};
    Object.keys(data).forEach(function (key) {
      if (Array.isArray(data[key])) {
        obj[key] = data[key][num];
      } else if (!enterOrLeave && !num || enterOrLeave && num) {
        obj[key] = data[key];
      }
    });
    return obj;
  };

  this.getTweenData = function (key, i, type) {
    var props = _this5.props;
    var enterOrLeave = type === 'enter' ? 0 : 1;
    var start = type === 'enter' ? 1 : 0;
    var end = type === 'enter' ? 0 : 1;
    var animate = _this5.getAnimData(props, key, i, enterOrLeave, end);
    var startAnim = type === 'enter' && (props.forcedReplay || !_this5.childrenShow[key]) ? _this5.getAnimData(props, key, i, enterOrLeave, start) : null;
    var ease = transformArguments(props.ease, key, i)[enterOrLeave];
    var duration = transformArguments(props.duration, key, i)[enterOrLeave];
    if (Array.isArray(ease)) {
      ease = ease.map(function (num) {
        return num * 100;
      });
      ease = TweenOne.easing.path('M0,100C' + ease[0] + ',' + (100 - ease[1]) + ',' + ease[2] + ',' + (100 - ease[3]) + ',100,0', { lengthPixel: duration / 16.6667 });
    }
    return { startAnim: startAnim, animate: animate, ease: ease, duration: duration, isArray: Array.isArray(animate) };
  };

  this.getTweenSingleData = function (startAnim, animate, ease, duration, delay, onStart, onComplete) {
    var startLength = Object.keys(startAnim || {}).length;
    var animation = _extends({
      onStart: onStart,
      onComplete: onComplete,
      duration: duration,
      delay: delay,
      ease: ease
    }, animate);
    var startAnimate = startLength ? _extends({ duration: 0 }, startAnim) : null;
    return { animation: animation, startAnimate: startAnimate };
  };

  this.getTweenEnterOrLeaveData = function (key, i, delay, type) {
    var animateData = _this5.getTweenData(key, i, type);
    var startAnim = animateData.startAnim;
    var animate = animateData.animate;
    var onStart = (type === 'enter' ? _this5.enterBegin : _this5.leaveBegin).bind(_this5, key);
    var onComplete = (type === 'enter' ? _this5.enterComplete : _this5.leaveComplete).bind(_this5, key);
    if (animateData.isArray) {
      var length = animate.length - 1;
      var animation = [];
      var startArray = [];
      animate.forEach(function (leave, ii) {
        var start = startAnim && startAnim[ii];
        var animObj = _this5.getTweenSingleData(start, leave, animateData.ease, animateData.duration / length, !ii ? delay : 0, !ii ? onStart : null, ii === length ? onComplete : null);
        animation.push(animObj.animation);
        if (animObj.startAnimate) {
          startArray.push(animObj.startAnimate);
        }
      });
      return startArray.concat(animation);
    }
    animateData = _this5.getTweenSingleData(startAnim, animate, animateData.ease, animateData.duration, delay, onStart, onComplete);
    return [animateData.startAnimate, animateData.animation].filter(function (item) {
      return item;
    });
  };

  this.getAnimData = function (props, key, i, enterOrLeave, startOrEnd) {
    /**
     * transformArguments 第一个为 enter, 第二个为 leave；
     * getTweenAnimConfig or getTweenType 第一个为到达的位置， 第二个为开始的位置。
     * 用 tween-one 的数组来实现老的动画逻辑。。。
     */
    return props.animConfig ? _this5.getTweenAnimConfig(transformArguments(props.animConfig, key, i)[enterOrLeave], startOrEnd, enterOrLeave) : _this5.getTweenType(transformArguments(props.type, key, i)[enterOrLeave], startOrEnd);
  };

  this.getChildrenToRender = function (child) {
    var _props = _this5.props,
        forcedReplay = _props.forcedReplay,
        leaveReverse = _props.leaveReverse,
        delay = _props.delay,
        interval = _props.interval;

    if (!child || !child.key) {
      return child;
    }
    var key = child.key;
    if (!_this5.state.childrenShow[key]) {
      return null;
    }
    var i = _this5.keysToLeave.indexOf(key);
    var animation = void 0;
    var isFunc = typeof child.type === 'function';
    var forcedJudg = isFunc ? {} : null;
    if (isFunc) {
      Object.keys(child.type).forEach(function (name) {
        if (typeDefault.indexOf(name) === -1) {
          forcedJudg[name] = child.type[name];
        }
      });
    }
    // 处理出场
    if (i >= 0) {
      if (_this5.leaveUnfinishedChild.indexOf(key) >= 0) {
        return _this5.saveTweenOneTag[key];
      }
      var $interval = transformArguments(interval, key, i)[1];
      var $delay = transformArguments(delay, key, i)[1];
      // 减掉 leaveUnfinishedChild 里的个数，因为 leaveUnfinishedChild 是旧的出场，不应该计录在队列里。
      var order = (leaveReverse ? _this5.keysToLeave.length - i - 1 : i) - _this5.leaveUnfinishedChild.length;
      $delay = $interval * order + $delay;
      animation = _this5.getTweenEnterOrLeaveData(key, i, $delay, 'leave');
    } else {
      // 处理进场;
      i = _this5.keysToEnterToCallback.indexOf(key);
      // appear=false 时，设定 childrenShow 和 tweenToEnter 都为 true, 这里不渲染 animation;
      if (_this5.tweenToEnter[key] && !forcedReplay) {
        // 如果是已进入的，将直接返回标签。。
        return createElement(TweenOne, {
          key: key,
          component: child.type,
          forcedJudg: forcedJudg,
          componentProps: child.props
        });
      } else if (!_this5.tweenToEnter[key]) {
        animation = _this5.enterAnimation[key] || _this5.getTweenEnterOrLeaveData(key, i, 0, 'enter');
        _this5.enterAnimation[key] = animation;
      }
    }
    var paused = _this5.keysToEnterPaused[key] && _this5.keysToLeave.indexOf(key) === -1;
    animation = paused ? null : animation;
    var tag = createElement(TweenOne, {
      key: key,
      component: child.type,
      forcedJudg: forcedJudg,
      componentProps: child.props,
      animation: animation
    });
    _this5.saveTweenOneTag[key] = tag;
    return tag;
  };

  this.performEnter = function (key, i) {
    var interval = transformArguments(_this5.props.interval, key, i)[0];
    var delay = transformArguments(_this5.props.delay, key, i)[0];
    _this5.placeholderTimeoutIds[key] = ticker.timeout(_this5.performEnterBegin.bind(_this5, key), interval * i + delay);
    if (_this5.keysToEnter.indexOf(key) >= 0) {
      _this5.keysToEnter.splice(_this5.keysToEnter.indexOf(key), 1);
    }
  };

  this.performEnterBegin = function (key) {
    var childrenShow = _this5.state.childrenShow;
    childrenShow[key] = true;
    delete _this5.keysToEnterPaused[key];
    ticker.clear(_this5.placeholderTimeoutIds[key]);
    delete _this5.placeholderTimeoutIds[key];
    _this5.setState({ childrenShow: childrenShow });
  };

  this.performLeave = function (key) {
    ticker.clear(_this5.placeholderTimeoutIds[key]);
    delete _this5.placeholderTimeoutIds[key];
  };

  this.enterBegin = function (key, e) {
    var elem = e.target;
    var animatingClassName = _this5.props.animatingClassName;
    elem.className = elem.className.replace(animatingClassName[1], '');
    if (elem.className.indexOf(animatingClassName[0]) === -1) {
      elem.className = (elem.className + ' ' + animatingClassName[0]).trim();
    }
    _this5.childrenShow[key] = true;
  };

  this.enterComplete = function (key, e) {
    if (_this5.keysToEnterPaused[key] || _this5.keysToLeave.indexOf(key) >= 0) {
      return;
    }
    var elem = e.target;
    elem.className = elem.className.replace(_this5.props.animatingClassName[0], '').trim();
    _this5.tweenToEnter[key] = true;
    delete _this5.enterAnimation[key];
    _this5.props.onEnd({ key: key, type: 'enter', target: elem });
  };

  this.leaveBegin = function (key, e) {
    var elem = e.target;
    var animatingClassName = _this5.props.animatingClassName;
    elem.className = elem.className.replace(animatingClassName[0], '');
    if (elem.className.indexOf(animatingClassName[1]) === -1) {
      elem.className = (elem.className + ' ' + animatingClassName[1]).trim();
    }
    delete _this5.tweenToEnter[key];
  };

  this.leaveComplete = function (key, e) {
    // 切换时同时触发 onComplete。 手动跳出。。。
    if (_this5.keysToEnterToCallback.indexOf(key) >= 0) {
      return;
    }
    var childrenShow = _this5.state.childrenShow;
    delete childrenShow[key];
    delete _this5.saveTweenOneTag[key];
    delete _this5.childrenShow[key];
    if (_this5.keysToLeave.indexOf(key) >= 0) {
      _this5.keysToLeave.splice(_this5.keysToLeave.indexOf(key), 1);
    }
    var needLeave = _this5.keysToLeave.some(function (c) {
      return childrenShow[c];
    });
    if (!needLeave) {
      var currentChildren = toArrayChildren(getChildrenFromProps(_this5.props));
      _this5.setState({
        children: currentChildren,
        childrenShow: childrenShow
      });
    }
    var elem = e.target;
    elem.className = elem.className.replace(_this5.props.animatingClassName[1], '').trim();
    _this5.props.onEnd({ key: key, type: 'leave', target: elem });
  };
};

QueueAnim.isQueueAnim = true;
export default QueueAnim;